\documentclass[12pt]{article}

\usepackage{caption}
\usepackage{graphicx}
\usepackage{tipa}
\usepackage{ot-tableau}
\usepackage[margin=1in]{geometry}
\usepackage{minted}
\usepackage{hyperref}

\usepackage{setspace}
\onehalfspacing

\usepackage{biblatex}
\addbibresource{references.bib}

\DeclareCaptionLabelFormat{parensnum}{(#2)}
\captionsetup[figure]{labelformat=parensnum,
                      labelsep=space,
                      justification=raggedright,
                      singlelinecheck=false}

\newcommand{\ident}{\textsc{Ident}}

\newcommand{\maxvplus}{\textsc{MaxFinalV}}
\newcommand{\maxplusv}{\textsc{MaxInitialV}}
\newcommand{\maxc}{\textsc{Max}}
\newcommand{\ftbin}{\textsc{FtBin}}
\newcommand{\ssp}{\textsc{SSP}}
\newcommand{\dep}{\textsc{Dep}}
\newcommand{\onset}{\textsc{Onset}}
\newcommand{\nocoda}{\textsc{NoCoda}}

\newcommand{\pref}[1]{(\ref{#1})}

\title{Computing Vowel Elision in Yoruba Collocations}
\author{Hemant Gouni}
\date{May 15th, 2023}

\begin{document}

\maketitle

\section{Introduction}

% Maybe add some background as Yoruba

The phenomenon of vowel hiatus in Yoruba, a language in the Niger-Congo family
spoken primarily in West Africa, is well-documented. A mature body of work
exists that explores the various aspects of it, largely from an
optimality-theoretic perspective \cite{ola2002yoruba, seidl2000yoruba,
pulleyblank1988vowel}. Two particularly well-studied instances of this problem
are the \textit{assimilation} case and the \textit{deletion} case. These are the
two primary strategies employed by the language for resolving sequences of two
or more vowels that occur at the boundary of two adjoined morphemes
(sequences of two vowels do not generally appear in Yoruba words due to
syllable structure constraints). This text will specifically explore the
second strategy of deletion, and in doing so, will specially attempt to provide
an analysis that is simple enough to be feasible to verify computationally. That
is, once we have developed our analysis, the core contribution of this work
will be to encode it as a computer program so it can be quickly and easily
verified whether it works for a range of corpus data. We employ an
optimality-theoretic perspective throughout, and provide a thorough discussion
in Section \ref{sec:computing-optimal-surface-forms} of the prior work on
computational interpretations of optimality theory. Afterwards, we describe
our own approach to automating our analysis and discuss its efficacy.

\section{Analysis}

In Yoruba, deletion occurs at morpheme boundaries. Specifically, when two
vowels become adjacent via concatenation of Yoruba morphemes, the first vowel
is generally deleted. This is shown in the following pairs of underlying and
surface forms, as shown below in \pref{fig:deletion-simple},
\pref{fig:deletion-except-1}, and \pref{fig:deletion-except-2}.

\begin{figure}[h]
\caption{Deletion in Yoruba}
\label{fig:deletion-simple}
\begin{tabular}{c|c|c|c}
    \textbf{Underlying} & \textbf{Surface} & \textbf{Underlying} & \textbf{Surface}\\
    \textipa{/ow\'o-k\'i-ow\'o/} & \textipa{[ow\'ok\'ow\'o]} & \textipa{/\textdyoghlig{}\'o-\`Ew\`u/} & \textipa{[\textdyoghlig{}\'Ew\`u]}\\
    \textipa{/OmO-k\'i-OmO/} & \textipa{[OmOk\'OmO]} & \textipa{/ra-\`Og\`Ed\`E/} & \textipa{[r\`Og\`Ed\`E]}\footnotemark\\
    \textipa{/se-ol\'u/} & \textipa{[sol\'u]} & \textipa{/n\'i-oko/} & \textipa{[l\'oko]}\\
    \textipa{/\textdyoghlig{}E-ed\'e/} & \textipa{[\textdyoghlig{}ed\'e]} & \textipa{/s\'i-O\textdyoghlig{}\`a/} & \textipa{[s\'O\textdyoghlig{}\`a]}\\
\end{tabular}
\end{figure}

\footnotetext{As you will see, this example contradicts our analysis. However,
it appears as a valid form only in a single source, so we note this and
continue as though it is an exception.}

% for handling [bimo], markedness constraint for preferring vowels to be
% approximately in the same place when both surrounding consonants share place?

However, [i] is always elided, regardless of whether it is the first or second
vowel in the sequence, as seen in \pref{fig:deletion-except-1}.

\begin{figure}[h]
\caption{Deletion of [i]}
\label{fig:deletion-except-1}
\begin{tabular}{c|c|c|c}
    \textbf{Underlying} & \textbf{Surface} & \textbf{Underlying} & \textbf{Surface}\\
    \textipa{/gb\'e-in\'O/} & \textipa{[gb\'en\'O]} & \textipa{/wo-il\`E/} & \textipa{[wol\`E]}\\
    \textipa{/gba-iS\'E/} & \textipa{[gbaS\'E]} & \textipa{/\textdyoghlig{}\'i-aSO/} & \textipa{[\textdyoghlig{}\'aSO]}\\
\end{tabular}
\end{figure}

However, when /u/ occurs at the end of the first morpheme it is always deleted,
unless followed by /i/ in which case /i/ is deleted, as seen in
\pref{fig:deletion-except-2}.

\begin{figure}[h]
\caption{Deletion of [u], except before [i]}
\label{fig:deletion-except-2}
\begin{tabular}{c|c|c|c}
    \textbf{Underlying} & \textbf{Surface} & \textbf{Underlying} & \textbf{Surface}\\
    \textipa{/\textdyoghlig{}u-igi/} & \textipa{[\textdyoghlig{}ugi]} & \textipa{/ru-epo/} & \textipa{[repo]}\\
    \textipa{/lu-il\`E/} & \textipa{[lul\`E]} & \textipa{/bu-omi/} & \textipa{[bomi]}\\
    \textipa{/b\'u-Oba/} & \textipa{[b\'Oba]}\\
\end{tabular}
\end{figure}

We can describe these three distinct groups of data straightforwardly. In
Yoruba, when two vowels become adjacent via concatenation of Yoruba morphemes,
the first vowel is deleted, unless the second vowel is less sonorous,
in which case it is deleted (the Yoruba vowel inventory and sonority scale is
discussed on page 4). This deletion occurs in order to ensure that syllables
always have an onset. This generalization can be analyzed from an
Optimality-theoretic viewpoint. To begin, the phenomena in
\pref{fig:deletion-simple} can be naturally accounted for with a prohibition
against onsetless syllables, so one of the conjoined vowels is deleted to
prevent such a syllable from surfacing. Specifically, a `V`, with any number of
`C`s after it, is not a valid candidate for a syllable, because it lacks an
onset. We can codify this observation via the constraint \onset, which
precisely moderates against candidate surface forms with syllables which lack
an onset. This is defined in \pref{def:onset-and-maxc}.

\begin{figure}[h]
    \caption{Definitions for \onset{} and \maxc.}
    \label{def:onset-and-maxc}
    \begin{center}
        \onset\\
        Assign one violation mark for every syllable which lacks an onset.\\
        \vspace{1em}
        \maxc\\
        Assign one violation mark for every segment that is present in the
        underlying form but not in the surface form.
    \end{center}
\end{figure}

We can now establish a ranking between \onset{} and \maxc, which is the
classic faithfulness constraint responsible for preventing deletion and which
also has a definition in \pref{def:onset-and-maxc}. We will see later that
\maxc{} is used as a simplifying assumption, and that its effect here can
be accounted for better by a couple more complex constraints.

\begin{figure}[h]
    \caption{\onset{} >> \maxc}
    \label{tableau:onset-wins}
    \begin{tableau}{c|c}
        \inp{\ips{\textdyoghlig{}E-ed\'e}}       \const{\onset} \const{\maxc}
        \cand[\Optimal]{.\textdyoghlig{}e.d\'e.} \vio{}         \vio{*}
        \cand{.\textdyoghlig{}E.e.d\'e.}         \vio{*!}       \vio{}
    \end{tableau}
\end{figure}

This tableau proves that Yoruba prefers to delete one of the conjoined vowels
rather than create a syllable without an onset. However, a question immediately
arises: there is an unconsidered candidate, in this tableau, one where the
morpheme-initial vowel [e] was deleted instead of the morpheme-final vowel
\textipa{[E]}, to create the candidate surface form
\textipa{[\textdyoghlig{}E.d\'e]}. This also does not violate \onset, and has
an equal number of violations of \maxc, as shown in the tableau in
\pref{tableau:onset-maxc-tie}. Why didn't Yoruba choose this surface form
instead?

\begin{figure}[h]
    \caption{A tie between two candidates!}
    \label{tableau:onset-maxc-tie}
    \begin{tableau}{c|c}
        \inp{\ips{\textdyoghlig{}E-ed\'e}} \const{\onset} \const{\maxc}
        \cand{.\textdyoghlig{}e.d\'e.}     \vio{}         \vio{*}
        \cand{.\textdyoghlig{}E.d\'e}      \vio{}         \vio{*}
    \end{tableau}
\end{figure}

The answer lies in Yoruba's preference for preserving morpheme-initial vowels
versus morpheme-final vowels. Cross-linguistically, onsets are more important
than codas--- looking to the corpus of Optimality Theory constraints, for
instance, we see that \onset{} exists to regulate against syllables
\textit{without} onsets, but \nocoda{} exists to regulate against syllables
\textit{with} codas. Given this cross-linguistic asymmetry, it is natural to
conclude that Yoruba's treatment of vowels at morpheme boundaries (which are
also syllable boundaries) follows a similar pattern.

To break the tie in \pref{tableau:onset-maxc-tie}, we introduce a morphemic
faithfulness constraint against vowel deletion at the beginnings of morpheme
boundaries. We call this constraint \maxplusv. Though this means that we must
consult morphology in order to determine correct phonological outputs,
observing the phenomenon in \pref{fig:deletion-simple}, we see that it is
fundamentally a morphological one, so we posit that relying on morphology here
presents the most productive path forward. We also propose its sibling
constraint, \maxvplus, which prohibits vowels from being deleted in
morpheme-final positions. We define both of these constraints in
\pref{def:maxvplus-and-maxplusv}. Note that we could define these without
specifying \textsc{-V}; that is, they could simply regulate against deletion
at morpheme boundaries, but we have chosen to specialize these to our analysis
to avoid unintended interactions with deletion in Yoruba unrelated to our work.

% \textbf{cite the paper from class as justification: onsets are generally more
% important than codas, onset vs nocoda}

\begin{figure}[h]
    \caption{Definitions for \maxplusv{} and \maxvplus.}
    \label{def:maxvplus-and-maxplusv}
    \begin{center}
        % Ident vowel-end-of-morpheme??
        \maxplusv\\
        Assign one violation mark for every vowel that is present at the
        beginning of a morpheme boundary in the UR and is not present in the
        SR.\\
        \vspace{1em}
        \maxvplus\\
        Assign one violation mark for every vowel that is present at the end of
        a morpheme boundary in the UR and is not present in the SR.
    \end{center}
\end{figure}

The tableau establishing their relative ranking is shown in
\pref{tableau:maxplusv-wins}.

\begin{figure}[h]
\caption{\maxplusv{} >> \maxvplus}
\label{tableau:maxplusv-wins}
\begin{tableau}{c|c}
    \inp{\ips{\textdyoghlig{}E-ed\'e}}    \const{\maxplusv} \const{\maxvplus}
    \cand[\Optimal]{\textdyoghlig{}ed\'e} \vio{}            \vio{*}
    \cand{\textdyoghlig{}Ed\'e}           \vio{*!}          \vio{}
\end{tableau}
\end{figure}

As \pref{tableau:maxplusv-wins} shows, Yoruba prefers morpheme final vowels to
be deleted over morpheme initial ones, because the deletion of the latter
constitutes a graver violation of \maxplusv. What this means is that we're not
\textit{really} dealing with \maxc{} as our primary faithfulness constraint, as
was implied by \pref{tableau:onset-wins}, but rather with our two faithfulness
constraints governing morpheme-initial versus morpheme-final vowel deletion. We
show an updated version of the tableau from \pref{tableau:onset-wins} in
\pref{tableau:onset-wins-v2} to account for this.

\begin{figure}[h]
    \caption{\onset{} >> \maxplusv}
    \label{tableau:onset-wins-v2}
    \begin{tableau}{c|c}
        \inp{\ips{\textdyoghlig{}E-ed\'e}}       \const{\onset} \const{\maxplusv}
        \cand[\Optimal]{.\textdyoghlig{}e.d\'e.} \vio{}         \vio{*}
        \cand{.\textdyoghlig{}E.e.d\'e.}         \vio{*!}       \vio{}
    \end{tableau}
\end{figure}

Our analysis so far accounts for the phenomena in \pref{fig:deletion-simple},
but not the phenomena in \pref{fig:deletion-except-1} or
\pref{fig:deletion-except-2}. We proceed, now, to analyze the first of these, in
which [i] is deleted regardless of whether it the morpheme initial or final
sound. One possible explanation as to why this is the case might be some
quality of the vowels themselves--- the frontness or backness of the vowels
appears to have no immediately discernible pattern with respect to deletion, so
we might try vowel height. Indeed, height appears to be correlated: [u] and
[i], which are both high vowels, are involved in the exceptional deletion
cases! We analyze both of these instances through the mechanism of sonority,
which offers an explanation for high vowels being involved in deletion--- they
are less sonorous. The sonority scale of vowels has been discussed in prior
work \cite{kenstowicz1997quality}. This scale is shown in
\pref{table:vowel-sonority}.

\begin{figure}[h]
    \caption{The vowel sonority scale (ordered by decreasing sonority)}
    \label{table:vowel-sonority}
    \begin{tabular}{c|c|c}
        \textbf{low} (\textsc{most} sonorous) & \textbf{mid} & \textbf{high} (\textsc{least} sonorous)\\
        /a/ & \textipa{/e E o O/} & /i u/\\
    \end{tabular}
\end{figure}

This helps inform why, for the data in \pref{fig:deletion-except-1}, [i] is
always elided, even though it appears morpheme-initially underlyingly.
Specifically, the language prefers to delete less sonorous vowels such as
[i] over more sonorous vowels. We can codify this intuition into a faithfulness
constraint, \ssp{} (which stands for `Sonority Sequencing Principle').
This constraint is defined in \pref{def:ssp}.

% use smth like PEAK-PROMINENCE here instead?
\begin{figure}[h]
    \caption{Definition of \ssp}
    \label{def:ssp}
    \begin{center}
        \ssp\\
        For each vowel in the surface form, assign one additional violation
        mark for every increment of distance away from most sonorous level of
        the sonority scale.
    \end{center}
\end{figure}

We can now attempt to determine the ranking of this constraint that results in
the phenomenon seen in \pref{fig:deletion-except-1} while preserving the
phenomenon in \pref{fig:deletion-simple}.

\begin{figure}[h!]
    \caption{\ssp{} >> \maxplusv}
    \label{tableau:ssp-wins}
    \begin{tableau}{c|c}
        \inp{\ips{gb\'e-in\'O}}    \const{\ssp} \const{\maxplusv}
        \cand[\Optimal]{gb\'en\'O} \vio{**}     \vio{*}
        \cand{gb\'in\'O}           \vio{***!}   \vio{}
    \end{tableau}
\end{figure}

The tableau in \pref{tableau:ssp-wins} shows that the language prefers to
delete a morpheme-initial vowel over a more sonorous vowel (\textipa{[\'e]}
rather than \textipa{[\'i]}). This ranking completely accounts for the pairs
shown in \pref{fig:deletion-except-1}. We would additionally like to rank
\onset{} and \ssp{} against each other, but with the data we have, they cannot
be. For valid surface forms, only deletion ever occurs in order to satisfy
\onset{} or \ssp. Every time a vowel is deleted, violations of either of these
constraints cannot increase (for \onset, because there's one less syllable
nucleus which requires an onset, and for \ssp, because there's one less
potentially non-low vowel). As a result, we cannot attempt a ranking between
\onset{} and \ssp{} either.

We proceed to account, now, for the
final set of exceptions shown in \pref{fig:deletion-except-2}. We can actually
account for this phenomenon with a slight modification to our sonority scale,
ranking [u] above [i] within it.

\begin{figure}[h]
    \caption{The vowel sonority scale (ordered by decreasing sonority)}
    \label{table:vowel-sonority-v2}
    \begin{tabular}{c|c|c|c}
        \textbf{low} (\textsc{most} sonorous) & \textbf{mid} & \textbf{mid} &
            \textbf{high} (\textsc{least} sonorous)\\
        /a/ & \textipa{/e E o O/} & /u/ & /i/\\
    \end{tabular}
\end{figure}

This modification enables us to account for the phenomena in
\pref{fig:deletion-except-2} by ranking /i/ as lower in the sonority scale of
Yoruba. This deals with the issue of /i/ deletion at the beginning of
the second vowel being preferred over /u/ deletion at the end of the first
vowel, because, as discussed before, a violation of \ssp{} represents a
maximally severe violation of the language's phonology. This is explicated in
the tableau shown here.

% \begin{figure}[h]
%     \caption{Definition for \ssp{} (v2)}
%     \label{def:ssp-v2}
%     \begin{center}
%         \ssp\\
%         The Yoruba vowel sonority scale is defined as in 
%     \end{center}
% \end{figure}

\begin{figure}[h]
    \caption{\ssp >> \maxplusv (part 2)}
    \label{tableau:ssp-wins-v2}
    \begin{tableau}{c|c}
        \inp{\ips{lu-\`ilE}}    \const{\ssp} \const{\maxplusv}
        \cand[\Optimal]{lul\`E} \vio{***}    \vio{*}
        \cand{l\`il\`E}         \vio{****!}  \vio{}
    \end{tableau}
\end{figure}

As we can see here, the fact that morpheme-final [u] deletion is dispreferred
over morpheme-initial [i] deletion (which violates a fairly high-ranked
\maxplusv{} constraint) in the phenomena shown in \pref{fig:deletion-except-2}
is straightforwardly dealt with by taking the language-generic SSP ranking and
theorizing that Yoruba possesses a specialized variant of it, as many languages
do. This sonority scale is motivated only linguistically, within the context
of our analysis, and not psycho-acoustically-- though that would be an
interesting direction for future work.

We now show a summary tableau for the input \textipa{/\textdyoghlig{}u-igi/}.

\begin{figure}[h!]
    \caption{Summary Tableau, attampt 1}
    \label{tableau:summary-one}
    \begin{tableau}{c:c|c|c}
        \inp{\ips{\textdyoghlig{}u-igi}}         \const{\onset} \const{\ssp}   \const{\maxplusv} \const{\maxvplus}
        \cand[\Optimal]{.\textdyoghlig{}u.gi.}   \vio{}         \vio{****!*}   \vio{*}           \vio{}
        \cand{.\textdyoghlig{}u.i.gi.}           \vio{*!}       \vio{*******}  \vio{}            \vio{}
        \cand{.\textdyoghlig{}i.gi.}             \vio{}         \vio{******!}  \vio{}            \vio{*}
        \cand{.\textdyoghlig{}a.gi.}             \vio{}         \vio{***}      \vio{*}           \vio{*}
    \end{tableau}
\end{figure}

We notice that candidate four is a winner threatening loser! It deletes both
of the non-sonorous vowels at the boundary of the two morphemes, and instead
epenthesizes an [a], which is a very sonorous vowel, incurring no violations of
\ssp. In order to prevent this winner-threatening loser, we introduce a
high-ranked \dep{} constraint. This is supported by our data, because we never
see epenthesis. We now show a simple ranking tableau that represents this argument.

\begin{figure}[h]
    \caption{\dep{} >> \ssp}
    \label{tableau:dep-wins}
    \begin{tableau}{c|c}
        \inp{\ips{\textdyoghlig{}u-igi}}       \const{\dep} \const{\ssp}
        \cand[\Optimal]{.\textdyoghlig{}u.gi.} \vio{}       \vio{*****}
        \cand{.\textdyoghlig{}a.gi.}           \vio{*!}     \vio{***}
    \end{tableau}
\end{figure}

We would additionally like to show a ranking for \dep{} over \onset, or
\onset{} over \dep, but unfortunately, this is impossible: we would need to
come up with a winning candidate that violates either \onset{} or \dep{},
neither of which is ever seen in the data.

Note that our winner-threatening loser could also have been created via a
featural change--- we can deal with this in a similar way, by introducing a
high-ranked \ident{} constraint. We show this below. For similar reasons to
that for \dep, \ident{} cannot be ranked against \onset. \dep{} and \ident{}
also cannot be ranked against each other, because we never see a surface
form that uses either.

\begin{figure}[h]
    \caption{\ident{} >> \ssp}
    \label{tableau:ident-wins}
    \begin{tableau}{c|c}
        \inp{\ips{\textdyoghlig{}u-igi}}       \const{\ident} \const{\ssp}
        \cand[\Optimal]{.\textdyoghlig{}u.gi.} \vio{}         \vio{*****}
        \cand{.\textdyoghlig{}a.gi.}           \vio{*!}       \vio{***}
    \end{tableau}
\end{figure}

And, finally, we can show our corrected summary tableau.

\begin{figure}[h]
    \caption{Final Summary Tableau}
    \label{tableau:summary-two}
    \resizebox{\textwidth}{!}{
    \begin{tableau}{c:c|c:c|c|c}
        \inp{\ips{\textdyoghlig{}u-igi}}       \const{\ident} \const{\dep} \const{\onset} \const{\ssp}   \const{\maxplusv} \const{\maxvplus}
        \cand[\Optimal]{.\textdyoghlig{}u.gi.} \vio{}         \vio{}       \vio{}         \vio{*****}    \vio{*}           \vio{}
        \cand{.\textdyoghlig{}u.i.gi.}         \vio{}         \vio{}       \vio{*!}       \vio{******!*} \vio{}            \vio{}
        \cand{.\textdyoghlig{}i.gi.}           \vio{}         \vio{}       \vio{}         \vio{******!}  \vio{}            \vio{*}
        \cand{.\textdyoghlig{}a.gi.}           \vio{*!}       \vio{*!}     \vio{}         \vio{***}      \vio{*}           \vio{*}
    \end{tableau}}
\end{figure}

Here, our previous winner-threatening-loser has a fatal violation of the
undominated \dep{} constraint, and so no longer threatens the winner!
We now have a complete ranking that accounts for all the data shown in
\pref{fig:deletion-simple}, \pref{fig:deletion-except-1}, and
\pref{fig:deletion-except-2}.

\pagebreak

\section{Computing Optimal Surface Forms}
\label{sec:computing-optimal-surface-forms}

\subsection{Introduction and Background}

We now turn to assigning a computational interpretation to our analysis.
Creating an algorithm to compute ideal outputs from Optimality-theoretic
constraints has been explored in prior work, though not extensively. Kartunnen
\cite{karttunen2006finite} explores a computational implementation of the
Optimality-theoretic analysis of Finnish stress using the finite state machine
description language XFST (\cite{karttunen2001applications} gives a broad
overview of finite state transducers as applied to morphological analysis and
parsing). Interestingly, such an implementation leads to insights about the
soundness of the preexisting analyses of Finnish stress--- namely, that they
are not. Key to this analysis is that it is an \textit{approximation}: indeed,
the paper itself notes that ``it has been known for a long time [\ldots] that
\textsc{OT} is not a finite-state system'', and that ``\textsc{OT} is
fundamentally more complex than [rule-based phonological systems]''.

Idsardi \cite{idsardi2006simple} explores this computational aspect, providing
a proof that generating an appropriate candidate set which can be evaluated
against some constraint ranking is \textit{NP-Hard}. This is a term used in
computability theory to describe a problem to which any number of other hard
problems can be \textit{reduced}. In essence, if there exists an efficient way
to solve this problem, a number of other incredibly difficult problems could
also be easily solved. Knowing a problem is NP-Hard is strong evidence that it
cannot be solved efficiently.

Heinz, Kobele, and Riggle \cite{heinz2009evaluating} contest this result,
showing that a different representation of \textsc{OT} grammars as a single
finite state transducer (instead of a sequence of finite state constriants)
averts the computational intractability issue demonstrated in
\cite{idsardi2006simple}. Additionally, they outline two subclasses of the
\textit{universal problem} of attempting to determine a valid constraint
ranking and underlying representations given only surface forms. Namely,
the \textit{simple problem} asks for optimal surface forms given an underlying
form and fixed constraint set \textsc{Con} and ranking \textsc{R}. The
\textit{quasi-universal problem} asks for an optimal surface form given
a fixed constraint set with any possible ranking.

Encoding our analysis as an algorithm has several advantages, namely, that we
make explicit the procedure for calculating surface forms from underlying ones,
forcing us to make obvious any implicit assumptions made in the analysis as we
step through it. Secondly, and perhaps more interestingly, this enables us to
test our analysis quickly and thoroughly given new data, ensuring that it holds
and giving us opportunities to improve it otherwise.

\subsection{Approach}
\label{subsec:approach}

We base our procedure, crucially, on bounded depth-first search. We first
describe a basic and idealized algorithm, before proceeding onwards to an
implementation section where we will discuss certain shortcuts which can be
taken due to convenient properties of vowel elision in Yoruba. Viewed as a
single function which takes an input and returns an output, our analysis 
takes as input an underlying form and a set of ranked constraints, and
searches for the correct output form. The search for the correct output is
of course the crucial portion here, and is the part on which most of the
discussion will be spent.

Our basic approach employs \textit{bounded depth-first search}. It is best to
illustrate this technique on a concrete example. Take, for instance, the
surface form \textipa{[sol\'u]} and its underlying representation
\textipa{/se-ol\'u/} \textbf{continue with this running example}. We will
demonstrate our technique on this mapping.

\subsubsection{Core Operations for Generating Candidates}

Our first order of business is to generate a reasonably large set of
permutations of \textipa{/se-ol\'u/}, one of which is the correct output form.
We are not yet attempting to identify which is the correct output form, only
generate it so it may be picked later. In effect, we are attempting to
efficiently emulate Optimality Theory's \textsc{Gen}. To do this, we intoduce
the following core transformations; we model each of these transformations as
functions of their own:

\begin{enumerate}
    \item \textbf{Delete}: Delete a segment
    \item \textbf{Epenthesize}: Insert a segment
    \item \textbf{Change}: Map a segment to another one
    \item \textbf{Metathesize}: Swap the positions of two segments
\end{enumerate}

\textbf{Delete} takes as input a form, such as \textipa{[sol\'u]}, and
randomly deletes one of the characters. For instance, it may delete
\textipa{[o]} to produce \textipa{[sl\'u]}, though again, this says little
about whether such a form would surface. It is more likely to delete inside the
word than at the edges of the word, following in line with broad phonological
generalizations about the markedness of deleting morpheme-initial or
morpheme-final segments (citation about this here?).

\textbf{Epenthesize} inserts a segment into its input and returns the new form.
For example, if given \textipa{[sol\'u]} as input, epenthesis may return
\textipa{[sool\'u]}. Again, it is more likely to epenthesize inside the form
than at its edges.

\textbf{Change}, to some extent, is functionally a composition of the previous
two operations, replacing one segment with another one. However, this does not
reflect how such transitions are modeled in the literature, using the
categorization of segments into their features. To accommodate this without
undertaking the modeling of autosegmental phonology
\cite{goldsmith1990autosegmental} in a computationally tractable way, we
manually partition the set of segments into phonologically similar (not
necessarily disjoint) sets, and attempt to map largely within these sets.
Illustrating concretely, we might classify all vowels in the language into one
set, and all sonorants into another:

\begin{enumerate}
    \item \textipa{a o O i E u}
    \item \textipa{l m n w j}
\end{enumerate}

The probability of a segment changing internally to either of these sets is
high, but the probability of a segment changing across one or the other is much
lower. We note that it may be necessary to adjust the weighting of these
probabilities based on the language, or on cross-linguistic data more generally.

\textbf{Metathesize}, finally, can similarly be viewed as a composition of the
delete and epenthesize, or as a special case of the change operation. It
differs, of course, in its ability to make targeted transpositions which are
thought, based on cross-linguistic data, to be atomic (meaning indivisible, or
inseparable into components) operations of their own. In particular, it's
significantly more likely to swap two adjacent segments, again deploying
cross-linguistic observations.

\subsubsection{Generating Candidates}

With these operations in hand, we're now ready to address the interesting
portion: generating candidates and identifying the ideal one. First up, a short
description of how candidates are generated. We start with the underlying
representation. We then use each of \texttt{delete}, \texttt{epenthesize},
\texttt{change}, and \texttt{metathesize} on the underlying form, 4 times each.
This produces an initial candidate set of 16 candidates. We repeat the process
again on each entry, producing 256 entries. We repeat two more times, yielding
65536 total candidates. We're now ready to evaluate this candidate set against
our ranked constraints, but before we do so, it is appropriate to discuss how,
precisely, we represent constraints in a computable way.

\subsubsection{Encoding Constraints}

We represent constraints as functions. Specifically, these functions take as
input a candidate surface form, compare it against the underlying
representation, and return a count of violations. The precise logic used to
compare a candidate surface form against the underlying representation will
depend on the nature of each constraint. For example, for the constraint
\textsc{Dep}, the function would compare the underlying form to the candidate
surface form and determine if the latter has any segments which are not present
in the former. Of course, it must also determine whether the seemingly
epenthetic segment is the result of \texttt{change} or \texttt{metathesize},
and if so, avoid outputting a violation mark for that segment. This could be
determined by comparing segments around the errant one for equality. If
corresponding segements are equal at corresponding indices of the underlying
representation and the candidate surface form, modulo the errant segment, we
can be reasonably sure that \texttt{change} has taken place, otherwise, if
they are not, we can be reasonably sure that \texttt{metathesize} is the
culprit.

\subsubsection{Evaluating Candidates}

We are now in the appropriate setting to identify the correct output form. In
order to do this, we must evaluate our entire set of constraints against all of
the 65536 candidate surface forms we generated previously. This will generate a
sequence of constraint violations, one for each candidate surface form. We
search through each sequence in parallel, looking at the number of violations
for each constraint at the same time, starting from the highest-ranked. We
determine the minimal number of violations for the current constraint, and
eliminate all candidates with violation counts that exceed this threshold. We
repeat until we have a single candidate left, and return this candidate.

\subsection{Implementation}

\begin{figure}[h]
\caption{Our representation of words in Yoruba, along with our strategy for deletion.}
\label{fig:impl-deletion}
\begin{minted}[linenos]{rust}
struct SyllabifiedCandidate {
    form: Vec<Segment>,
    rng: StdRng,
}

impl SyllabifiedCandidate {
    fn delete(mut self) -> Self {
        if !self.form.is_empty() {
            self.form.remove(self.rng.gen_range(0..self.form.len()));
        }
        self
    }
}
\end{minted}
\end{figure}

We now describe key details of our implementation. The full source code may be
found at
\href{https://github.com/hemantgouni/linguistics-capstone}{github.com/hemantgouni/linguistics-capstone}.
Starting with the basics, Figure \pref{fig:impl-deletion} shows both our
representation of Yoruba words and our simple handling of deletion.
Specifically, a word is represented as a list of segments; this is denoted by
\texttt{Vec<Segment>} on line 2. At this point, it is reasonable to ask: why
not represent words simply as a list of characters? What's the difference
between a character and a segment? This reflects a complication in computers'
handling of text beyond the simple English characters covered by the ASCII
character encoding. Unicode, an improvement of ASCII that handles many more
languages beyond those which use the Latin alphabet, would consider the accent
mark and letter \textipa{O} in \textipa{\'O}, to be separate characters and not
parts of the same. We must sidestep this issue by parsing words into
\textit{graphemes}, which accounts for the intuitive notion of what a character
is: \textipa{\'O} is a single grapheme.

With that technical hiccup out of the way, our implementation of deletion is
much simpler. It is interesting to note that within the context of our
analysis, deletion turns out to be the most important of the operations to
implement, because winning candidates are always generated via deletion (due to
high-ranking \dep{} and \ident{} constraints). In fact, in the context of our
specific analysis, it is easy to generate \textit{all possible} surface forms
instead of limiting ourselves to the previously mentioned 65536 output forms,
simply by choosing to delete or not delete each segment. This yields $2^n$
possible output forms for a given input form, where $n$ is the number of
segments in the input form. We implement deletion by picking a random element
of the list of segments and removing it. Because we cluster characters by
Unicode graphemes, the probability of any single character being deleted is
evenly distributed between all in a given word.

\begin{figure}[h!]
\caption{Our implementation of \onset}
\label{fig:impl-onset}
\begin{minted}[linenos]{rust}
impl Constraint for Onset {
    fn evaluate(self, surface: SyllabifiedCandidate) -> usize {
        let syllabi = surface
            .form
            .iter()
            .filter(|seg| seg.syllable_index == SyllableIndex::Nucleus)
            .count();

        let onsets = surface
            .form
            .iter()
            .filter(|seg| seg.syllable_index == SyllableIndex::Onset)
            .count();

        syllabi - onsets
    }
}
\end{minted}
\end{figure}

The other significant portion of our implementation, beyond generating
candidates, is evaluating them. This, of course, is done with constraints.
Figure \pref{fig:impl-onset} shows our implementation of the \onset{}
markedness constraint. On lines 2-7, we count the number of syllable nuclei in
the input (a \texttt{SyllabifiedCandidate} from Figure
\pref{fig:impl-deletion}). On lines 9-13, we count the number of onsets. Onsets
and nuclei are calculated, along with other linguistic data, upon the creation
of a \texttt{SyllabifiedCandidate}; we merely analyze them here. The number of
violations of \onset{} is given by the number of nuclei minus the number of
onsets. This will never be a negative number, because the algorithm that marks
onsets and nuclei will only create one onset per nucleus, at most (because this
is the maximum allowed by Yoruba).

\begin{figure}[h]
\caption{The implementation of \dep}
\label{fig:impl-dep}
\begin{minted}[linenos]{rust}
struct Dep(SyllabifiedCandidate);

impl Constraint for Dep {
    fn evaluate(self, surface: SyllabifiedCandidate) -> usize {
        let self_str: String = self.0.into();
        let surface_str: String = surface.into();

        let diff = TextDiff::from_graphemes::<String>(&self_str, &surface_str);

        diff.ops()
            .iter()
            .filter(|op| matches!(op, DiffOp::Insert { .. }))
            .count()
    }
}
\end{minted}
\end{figure}

Of course, no discussion of constraints would be complete without
\textit{faithfulness} constraints. These present an interesting challenge, but
we first provide an overview of the implementation, which is provided in Figure
\pref{fig:impl-dep}. On lines 5 and 6, we respectively turn the original
underlying form and the candidate surface form into their string
respresentations. We then use a diff algorithm on these strings on line 8,
which returns a sequence of operations which could be performed on the original
underlying form to morph it into the candidate surface form given as input. On
lines 10-13, we count the number of insertion operations returned by the diff
algorithm.

A difficult and subtle complication arises here: how does the diff algorithm
\textit{know} what counts as an insertion, deletion, or change? For instance,
changing \textipa{/ow\'o-k\'i-ow\'o/} into \textipa{[ow\'ok\'ow\'o]} is a
relatively straightforward case of deletion. But what about
\textipa{[ow\'ak\'iow\'o]}? In this case, the diff algorithm could decide that
\textipa{[\'o]} was deleted and \textipa{[\'a]} inserted. Or it could instead
say that \textipa{[\'o]} changed into \textipa{[\'a]}. Which of these occurs is
linguistically relevant. This has not yet caused problems on real corpus data,
but when it does, a potential solution is fine-tuning the diff algorithm to
choose the more linguistically sound operations as outputs, making it aware of
autosegmental phonology when it, for example, is choosing between a replacement
operation or a insertion + deletion operations.

To this point, our descriptions have been fairly abstract, so it is best to
illustrate with an example. Given \textipa{/ow\'o-k\'i-ow\'o/} as input, how
would we generate a random candidate output form from it? And how would we
evaluate it against \onset{} and \dep?

For the sake of simplicity, we'll perform a single deletion operation. To do
this, we must parse \textipa{/ow\'o-k\'i-ow\'o/} from a string into a
\texttt{SyllabifiedCandidate}. We split it into each of its graphemes, creating
the list \{\textipa{o,w,\'o,k,\'i,o,w,\'o}\}. To perform a deletion, we simply
choose a random element of this list, say, [k]. This yields
\{\textipa{o,w,\'o,\'i,o,w,\'o}\}.

To find the number of \onset{} violations, we note that our list is annotated,
internally, as \{\texttt{Nucleus}, \texttt{Onset}, \texttt{Nucleus},
\texttt{Nucleus}, \texttt{Nucleus}, \texttt{Onset}, \texttt{Nucleus}\}.
Counting the number of nuclei, we find that there are 5. There are only two
onsets. 5 - 2 = 3, so there are 3 violations of \onset.

Finally, to count the number of \dep{} violations, we turn
\{\textipa{o,w,\'o,\'i,o,w,\'o}\} back into the string
[\textipa{ow\'o\'iow\'o}]. We then use a diff algorithm to determine the
sequence of edit operations that could be used to arrive at this string from
\textipa{/ow\'o-k\'i-ow\'o/}. In this case, it tells us that a single
\texttt{Delete} is all that is necessary, as expected. This does not cause any
violations of \dep{} because it is not an \texttt{Insert} operation, so we
return 0 violations.

\subsection{Analysis on corpus data}

In this section we will evaluate all of our collected Yoruba underlying
representations against the expected surface forms. The constraints used in our
analysis, along with their rankings, are listed here:

\begin{enumerate}
    \item
        \begin{enumerate}
            \item \ident{}
            \item \dep{}
        \end{enumerate}
    \item
        \begin{enumerate}
            \item \onset{}
            \item \ssp{}
            \item \maxc{}
        \end{enumerate}
    \item
        \begin{enumerate}
            \item \maxplusv{}
        \end{enumerate}
    \item
        \begin{enumerate}
            \item \maxvplus{}
        \end{enumerate}
\end{enumerate}

The number under which each constraint is listed denotes its rank. For example,
\ident{} and \dep{} have the highest ranking, followed by \onset{}, \ssp{}, and
\maxc{}. This largely matches Fig. \pref{tableau:summary-two}, but with the
inclusion of an extra \maxc{} constraint at rank two. This is necessary
because, otherwise, our program (correctly) finds deleting the input form to be
the optimal solution to the set of constraints given. That is, neither of the
rank 1 constraints (\ident{} and \dep{}), nor the constraints immediately below
them (\onset{} and \ssp{}), generate violations for deleting words. On the
other hand, a form with no segments will \textit{always} generate less
violations of \onset{} and \ssp{} than one which does-- the mere presence of a
vowel in a form is sufficient to generate \ssp{} violations. Adding a \maxc{}
constraint ranked equally to \onset{} and \ssp{} addresses this. Indeed, this
is not an issue with our implementation, but a more fundamental issue with our
analysis which was found by it. In that sense, we can see that the benefits of
computationally encoding the analysis are already emerging.

An additional point to note is that, when evaluating candidates, instead of
considering equally-ranked constraints individually, we treat violations
between them cumulatively. As a result, since \ssp{} generates multiple
violations at a time (for instance [i] will generate 3 violations, per Figure
\pref{table:vowel-sonority-v2}), in order for \maxc{} to adequately regulate
against deletion, it must generate multiple (specifically, 3) violations for
each deletion. In addition, \onset{}, being equally ranked to \ssp{} and
\maxc{}, must also do this. This quirk of our implementation is certainly
unconventional among the OT literature, and further study might better support
some of these choices (or provide more elegant alternative solutions).

Beyond these issue, our analysis is sound. Given an underlying Yoruba form, the
program implementing it will produce the appropriately vowel-elided surface
form. In other words, given the information in the `Underlying' columns of
tables \pref{fig:deletion-simple}, \pref{fig:deletion-except-1},
\pref{fig:deletion-except-1}, our program outputs the form expected in the
'Surface' columns (excepting \textipa{/n\'i-oko/} \rightarrow{}
\textipa{[l\'oko]}, since the n \rightarrow{} l transition occurs for reasons
unrelated to our analysis; we also ignore tone markers here, because it is a
related but orthogonal phenomenon unhandled by our original analysis).

In fact, it will even produce the intuitively expected surface form when given
underlying forms which do not exist. For instance, given \textipa{[so-el\'u]}
as an input, it will produce \textipa{/sel\'u/}, due to \maxplusv{} regulating
more strictly against initial vowel deletion than deletion of final vowels.

\section{Concluding}

In this paper, we presented a classic Optimality-Theoretic analysis of
conjoined vowel elision in Yoruba. We then implemented it as a computer
program, finding a subtle issue in the analysis. With these issues addressed in
the implementation, our program outputs the correctly vowel-elided surface
form, given an underlying representation. Future work could go in several
interesting directions. Within the domain of Yoruba, the original analysis and
its implementation could be extended to handle the assimilatory strategy for
dealing with sequences of vowels at morpheme boundaries (as discussed in
\cite{ola2002yoruba}), as well as tone. This would likely involve extending
surface candidate generation to the full idealized algorithm described in
Section \ref{subsec:approach}, contending with epenthesis, metathesis, and
segment changes in addition to deletion. The implementation, as it exists,
faithfully models the parts of the algorithm in \ref{subsec:approach} that are
necessary in the context of Yoruba, so this would largely be a case of
extending the existing machinery.

\pagebreak

\section{Appendix}

\begin{figure}[h]
\caption{Yoruba Surface Forms}
\label{fig:data}
\begin{tabular}{c c c c}
    \textbf{Word} & \textbf{Gloss} & \textbf{Word} & \textbf{Gloss}\\
    \textipa{ow\'o} & money & \textipa{k\'i} & any\\
    \textipa{OmO} & child & se & cook\\
    \textipa{ol\'u} & mushrooms & \textipa{\textdyoghlig{}E} & eat\\
    \textipa{ed\'e} & shrimp & \textipa{\textdyoghlig{}\'o} & burn\\
    \textipa{\`Ew\`u} & clothing & \textipa{Ra} & buy\\
    \textipa{\`Og\`Ed\`E} & banana & \textipa{n\'i} & at\\
    \textipa{s\'i} & to & \textipa{O\textdyoghlig{}\`a} & market\\
    \textipa{ow\'ok\'ow\'o} & any money at all | bad money & \textipa{\textdyoghlig{}ed\'e} & eat shrimp\\
    \textipa{OmOk\'OmO} & any child at all | bad child & \textipa{sol\'u} & cook mushrooms\\
    \textipa{\textdyoghlig{}\'Ew\`u} & burn clothing & \textipa{R\`Og\`Ed\`E} & buy bananas\\
    \textipa{l\'oko} & at the farm & \textipa{s\'O\textdyoghlig{}\`a} & to the market\\
    \textipa{gb\'e} & lift & \textipa{in\'O} & lamp\\
    \textipa{gba} & take & \textipa{iS\'E} & job\\
    \textipa{wo} & look & \textipa{il\`E} & ground\\
    \textipa{\textdyoghlig{}\'i} & steal & \textipa{aSO} & clothes\\
    \textipa{gb\'en\'O} & lift the lamp & \textipa{gbaS\'E} & take a job\\
    \textipa{wol\`E} & look at the ground & \textipa{\textdyoghlig{}\'aSO} & steal clothes\\
    \textipa{\textdyoghlig{}u} & throw & \textipa{igi} & stick\\
    \textipa{lu} & hit & \textipa{il\`E} & ground\\
    \textipa{bu} & take & \textipa{omi} & water\\
    \textipa{Ru} & carry & \textipa{epo} & oil\\
    \textipa{b\'u} & abuse & \textipa{Oba} & king\\
    \textipa{\textdyoghlig{}ugi} & throw a stick & \textipa{lul\`E} & hit the ground\\
    \textipa{bomi} & take water & \textipa{Repo} & carry oil\\
    \textipa{b\'Oba} & abuse the king & \textipa{b\'i} & have\\
    \textipa{b\'imO} & have a baby\\
\end{tabular}
\end{figure}

\pagebreak

\printbibliography

\end{document}
